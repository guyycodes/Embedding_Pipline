import { Box } from '@mui/material';
import React, { useEffect, useRef } from 'react';

const ANIMATION_SETTINGS = {
    ROTATION_SPEED_X: 0.00013,  // Base rotation speed on X axis
    ROTATION_SPEED_Y: 0.00013,  // Base rotation speed on Y axis
    NODE_SPEED: 0.04,        // Base speed of nodes
    FLOW_SPEED: 0.05,        // Speed of data flow
    GLOW_SPEED: 0.4,         // Speed of glow animation
};

// Visual Settings
const VISUAL_SETTINGS = {
    BACKGROUND_COLOR: '#111',       // Background color
    NODE_COLOR: {
        ROOT: 'hsla(0,60%,light%,alp)',         // Root node color (red hue)
        CONNECTION: 'hsla(200,60%,light%,alp)',  // Connection color (blue hue)
        END: 'hsla(160,20%,light%,alp)',        // End node color (green hue)
        DATA: 'hsla(40,80%,light%,alp)',        // Data flow color (orange hue)
    },
    WIREFRAME: {
        COLOR: '#88f',
        WIDTH: 0.1,
    },
};

// Network Structure Settings
const NETWORK_SETTINGS = {
    RANGE: 180,              // Maximum range of the network
    BASE_CONNECTIONS: 30,     // Minimum connections per node
    ADDED_CONNECTIONS: 5,    // Maximum additional connections
    BASE_SIZE: 5,           // Base size of nodes
    MIN_SIZE: 1,            // Minimum size of nodes
    NODE_DISTANCE: 40,      // Base distance between nodes
    DEPTH: 250,             // 3D depth of the network
    FOCAL_LENGTH: 250,      // Camera focal length
};

const NeuralNetworkBackground = () => {
    const canvasRef = useRef(null);
    
    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        let w = canvas.width = window.innerWidth;
        let h = canvas.height = window.innerHeight;
        
        // Updated opts object using our constants
        const opts = {
            range: NETWORK_SETTINGS.RANGE,
            baseConnections: NETWORK_SETTINGS.BASE_CONNECTIONS,
            addedConnections: NETWORK_SETTINGS.ADDED_CONNECTIONS,
            baseSize: NETWORK_SETTINGS.BASE_SIZE,
            minSize: NETWORK_SETTINGS.MIN_SIZE,
            dataToConnectionSize: 0.4,
            sizeMultiplier: 0.7,
            allowedDist: NETWORK_SETTINGS.NODE_DISTANCE,
            baseDist: NETWORK_SETTINGS.NODE_DISTANCE,
            addedDist: 30,
            connectionAttempts: 100,
            dataToConnections: 1,
            baseSpeed: ANIMATION_SETTINGS.NODE_SPEED,
            addedSpeed: ANIMATION_SETTINGS.FLOW_SPEED,
            baseGlowSpeed: ANIMATION_SETTINGS.GLOW_SPEED,
            addedGlowSpeed: ANIMATION_SETTINGS.GLOW_SPEED,
            rotVelX: ANIMATION_SETTINGS.ROTATION_SPEED_X,
            rotVelY: ANIMATION_SETTINGS.ROTATION_SPEED_Y,
            repaintColor: VISUAL_SETTINGS.BACKGROUND_COLOR,
            connectionColor: VISUAL_SETTINGS.NODE_COLOR.CONNECTION,
            rootColor: VISUAL_SETTINGS.NODE_COLOR.ROOT,
            endColor: VISUAL_SETTINGS.NODE_COLOR.END,
            dataColor: VISUAL_SETTINGS.NODE_COLOR.DATA,
            wireframeWidth: VISUAL_SETTINGS.WIREFRAME.WIDTH,
            wireframeColor: VISUAL_SETTINGS.WIREFRAME.COLOR,
            depth: NETWORK_SETTINGS.DEPTH,
            focalLength: NETWORK_SETTINGS.FOCAL_LENGTH,
            vanishPoint: {
                x: w / 2,
                y: h / 2
            }
        };

        let connections = [];
        let toDevelop = [];
        let data = [];
        let all = [];
        let tick = 0;
        let animating = false;
        const Tau = Math.PI * 2;

        let sinX = 0;
        let sinY = 0;
        let cosX = 0;
        let cosY = 0;

        const squareRange = opts.range * opts.range;
        const squareAllowed = opts.allowedDist * opts.allowedDist;
        const mostDistant = opts.depth + opts.range;

        class Connection {
            constructor(x, y, z, size) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.size = size;
                this.screen = {};
                this.links = [];
                this.probabilities = [];
                this.isEnd = false;
                this.glowSpeed = opts.baseGlowSpeed + opts.addedGlowSpeed * Math.random();
            }

            link() {
                if (this.size < opts.minSize) {
                    this.isEnd = true;
                    return;
                }

                let links = [];
                let connectionsNum = opts.baseConnections + Math.random() * opts.addedConnections | 0;
                let attempt = opts.connectionAttempts;

                while (links.length < connectionsNum && --attempt > 0) {
                    let alpha = Math.random() * Math.PI;
                    let beta = Math.random() * Tau;
                    let len = opts.baseDist + opts.addedDist * Math.random();

                    let cosA = Math.cos(alpha);
                    let sinA = Math.sin(alpha);
                    let cosB = Math.cos(beta);
                    let sinB = Math.sin(beta);

                    let pos = {
                        x: this.x + len * cosA * sinB,
                        y: this.y + len * sinA * sinB,
                        z: this.z + len * cosB
                    };

                    if (pos.x * pos.x + pos.y * pos.y + pos.z * pos.z < squareRange) {
                        let passedExisting = true;
                        let passedBuffered = true;

                        for (let i = 0; i < connections.length; ++i) {
                            if (squareDist(pos, connections[i]) < squareAllowed)
                                passedExisting = false;
                        }

                        if (passedExisting) {
                            for (let i = 0; i < links.length; ++i) {
                                if (squareDist(pos, links[i]) < squareAllowed)
                                    passedBuffered = false;
                            }
                        }

                        if (passedExisting && passedBuffered)
                            links.push({ x: pos.x, y: pos.y, z: pos.z });
                    }
                }

                if (links.length === 0) {
                    this.isEnd = true;
                } else {
                    for (let i = 0; i < links.length; ++i) {
                        let pos = links[i];
                        let connection = new Connection(pos.x, pos.y, pos.z, this.size * opts.sizeMultiplier);
                        this.links[i] = connection;
                        all.push(connection);
                        connections.push(connection);
                    }
                    for (let i = 0; i < this.links.length; ++i) {
                        toDevelop.push(this.links[i]);
                    }
                }
            }

            step() {
                this.setScreen();
                this.screen.color = (this.isEnd ? opts.endColor : opts.connectionColor)
                    .replace('light', 30 + ((tick * this.glowSpeed) % 30))
                    .replace('alp', .2 + (1 - this.screen.z / mostDistant) * .8);

                for (let i = 0; i < this.links.length; ++i) {
                    ctx.moveTo(this.screen.x, this.screen.y);
                    ctx.lineTo(this.links[i].screen.x, this.links[i].screen.y);
                }
            }

            draw() {
                ctx.fillStyle = this.screen.color;
                ctx.beginPath();
                ctx.arc(this.screen.x, this.screen.y, this.screen.scale * this.size, 0, Tau);
                ctx.fill();
            }

            setScreen() {
                let x = this.x;
                let y = this.y;
                let z = this.z;

                let Y = y;
                y = y * cosX - z * sinX;
                z = z * cosX + Y * sinX;

                let Z = z;
                z = z * cosY - x * sinY;
                x = x * cosY + Z * sinY;

                this.screen.z = z;

                z += opts.depth;

                this.screen.scale = opts.focalLength / z;
                this.screen.x = opts.vanishPoint.x + x * this.screen.scale;
                this.screen.y = opts.vanishPoint.y + y * this.screen.scale;
            }
        }

        class Data {
            constructor(connection) {
                this.glowSpeed = opts.baseGlowSpeed + opts.addedGlowSpeed * Math.random();
                this.speed = opts.baseSpeed + opts.addedSpeed * Math.random();
                this.screen = {};
                this.setConnection(connection);
            }

            reset() {
                this.setConnection(connections[0]);
                this.ended = 2;
            }

            step() {
                this.proportion += this.speed;
                if (this.proportion < 1) {
                    this.x = this.ox + this.dx * this.proportion;
                    this.y = this.oy + this.dy * this.proportion;
                    this.z = this.oz + this.dz * this.proportion;
                    this.size = (this.os + this.ds * this.proportion) * opts.dataToConnectionSize;
                } else {
                    this.setConnection(this.nextConnection);
                }

                this.screen.lastX = this.screen.x;
                this.screen.lastY = this.screen.y;
                this.setScreen();
                this.screen.color = opts.dataColor
                    .replace('light', 40 + ((tick * this.glowSpeed) % 50))
                    .replace('alp', .2 + (1 - this.screen.z / mostDistant) * .6);
            }

            draw() {
                if (this.ended) return --this.ended;

                ctx.beginPath();
                ctx.strokeStyle = this.screen.color;
                ctx.lineWidth = this.size * this.screen.scale;
                ctx.moveTo(this.screen.lastX, this.screen.lastY);
                ctx.lineTo(this.screen.x, this.screen.y);
                ctx.stroke();
            }

            setConnection(connection) {
                if (connection.isEnd) this.reset();
                else {
                    this.connection = connection;
                    this.nextConnection = connection.links[connection.links.length * Math.random() | 0];

                    this.ox = connection.x;
                    this.oy = connection.y;
                    this.oz = connection.z;
                    this.os = connection.size;

                    this.nx = this.nextConnection.x;
                    this.ny = this.nextConnection.y;
                    this.nz = this.nextConnection.z;
                    this.ns = this.nextConnection.size;

                    this.dx = this.nx - this.ox;
                    this.dy = this.ny - this.oy;
                    this.dz = this.nz - this.oz;
                    this.ds = this.ns - this.os;

                    this.proportion = 0;
                }
            }

            setScreen() {
                let x = this.x;
                let y = this.y;
                let z = this.z;

                let Y = y;
                y = y * cosX - z * sinX;
                z = z * cosX + Y * sinX;

                let Z = z;
                z = z * cosY - x * sinY;
                x = x * cosY + Z * sinY;

                this.screen.z = z;

                z += opts.depth;

                this.screen.scale = opts.focalLength / z;
                this.screen.x = opts.vanishPoint.x + x * this.screen.scale;
                this.screen.y = opts.vanishPoint.y + y * this.screen.scale;
            }
        }

        function squareDist(a, b) {
            let x = b.x - a.x;
            let y = b.y - a.y;
            let z = b.z - a.z;
            return x * x + y * y + z * z;
        }

        function init() {
            connections.length = 0;
            data.length = 0;
            all.length = 0;
            toDevelop.length = 0;

            let connection = new Connection(0, 0, 0, opts.baseSize);
            connection.step = function() {
                this.setScreen();
                this.screen.color = opts.rootColor
                    .replace('light', 30 + ((tick * this.glowSpeed) % 30))
                    .replace('alp', (1 - this.screen.z / mostDistant) * .8);

                for (let i = 0; i < this.links.length; ++i) {
                    ctx.moveTo(this.screen.x, this.screen.y);
                    ctx.lineTo(this.links[i].screen.x, this.links[i].screen.y);
                }
            };

            connections.push(connection);
            all.push(connection);
            connection.link();

            while (toDevelop.length > 0) {
                toDevelop[0].link();
                toDevelop.shift();
            }

            if (!animating) {
                animating = true;
                anim();
            }
        }

        function anim() {
            window.requestAnimationFrame(anim);

            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = opts.repaintColor;
            ctx.fillRect(0, 0, w, h);

            ++tick;

            let rotX = tick * opts.rotVelX;
            let rotY = tick * opts.rotVelY;

            cosX = Math.cos(rotX);
            sinX = Math.sin(rotX);
            cosY = Math.cos(rotY);
            sinY = Math.sin(rotY);

            if (data.length < connections.length * opts.dataToConnections) {
                let datum = new Data(connections[0]);
                data.push(datum);
                all.push(datum);
            }

            ctx.globalCompositeOperation = 'lighter';
            ctx.beginPath();
            ctx.lineWidth = opts.wireframeWidth;
            ctx.strokeStyle = opts.wireframeColor;
            all.forEach(item => item.step());
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
            all.sort((a, b) => b.screen.z - a.screen.z);
            all.forEach(item => item.draw());
        }

        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#ccc';
        ctx.font = '50px Verdana';
        ctx.fillText('Calculating Nodes', w / 2 - ctx.measureText('Calculating Nodes').width / 2, h / 2 - 15);

        // Handle window resize
        const handleResize = () => {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            opts.vanishPoint.x = w / 2;
            opts.vanishPoint.y = h / 2;
            ctx.fillRect(0, 0, w, h);
        };

        window.addEventListener('resize', handleResize);
        window.addEventListener('click', init);

        // Start the animation
        setTimeout(init, 4);

        return () => {
            window.removeEventListener('resize', handleResize);
            window.removeEventListener('click', init);
        };
    }, []);

    return (
        <Box
            sx={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 0,
                '& canvas': {
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%'
                }
            }}
        >
            <canvas ref={canvasRef} />
        </Box>
    );
};

export const BackgroundWrapper = ({ children }) => {
    return (
        <Box
            sx={{
                minHeight: '100vh',
                position: 'relative',
                bgcolor: '#040203',
            }}
        >
            <NeuralNetworkBackground />
            <Box sx={{ position: 'relative', zIndex: 1 }}>
                {children}
            </Box>
        </Box>
    );
};

export default BackgroundWrapper;